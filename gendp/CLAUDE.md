# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

GenDP (Genomic Data Processing) is a cycle-accurate simulator for a domain-specific accelerator designed for genomic sequence alignment algorithms. The simulator models a hierarchical Processing Element (PE) array with scratchpad memory (SPM), supporting algorithms like BWA-MEM, PairHMM, POA (Partial Order Alignment), Chain, and WFA (Wavefront Alignment).

## Build Commands

### Main Simulator

```bash
# Build the simulator (address sanitizer enabled by default)
make

# Build without address sanitizer
make ADDRESS_SANITIZER=0

# Build with debug symbols
make debug=1

# Build with profiling
make profile=1

# Clean build
make clean
```

The main executable is `sim` in the root directory.

### Kernel Libraries

Each genomic kernel has its own build system in `kernel/`:

```bash
# BWA-MEM (Band Smith-Waterman)
cd kernel/bwa-mem && make -j

# Chain
cd kernel/chain && make -j print=1

# PairHMM
cd kernel/PairHMM && make -j

# POA (Partial Order Alignment)
cd kernel/poaV2 && make -j
```

## Running the Simulator

### Command-Line Interface

```bash
./sim -k <kernel> -i <input_file> -o <output_file> -n <num_cases>

Options:
  -k <kernel>    Kernel selection:
                   1 = bsw (BWA-MEM)
                   2 = phmm (PairHMM)
                   3 = poa (Partial Order Alignment)
                   4 = chain
                   5 = wfa (Wavefront Alignment)
  -i <file>      Input data file
  -o <file>      Output file
  -n <num>       Number of simulation cases (-1 = entire dataset)
  -s             Show output
  -h             Help
```

### Example Workflows

#### BSW (BWA-MEM)
```bash
# Preprocess dataset
python3 scripts/preprocess_bsw_datasets.py <input> <output>

# Generate golden output from kernel
cd kernel/bwa-mem && make -j
./ksw-test -i <input> -o <output> -x -n 2000000

# Run simulator
cd ../..
bash scripts/bsw_throughput.sh -1
```

#### WFA (Wavefront Alignment)
```bash
# Run simulator with WFA kernel
./sim -k 5 -i <input_file> -o <output_file> -n <num_cases>

# Verify correctness (compares wavefront traces)
python3 scripts/wfa_check_correctness.py <output_file> <expected_output>

# Or use the validation wrapper script
bash scripts/wfa_run_validation.sh
```

## Architecture

### System Hierarchy

The simulator implements a hierarchical PE array architecture:

```
Array Controller (pe_array)
├── 16 addressing registers (gr[0..15])
├── Input/Output buffers
├── 4 FIFOs
└── Controls 4 PEs via set_PC
    │
    ├── PE[0] ──▶ PE[1] ──▶ PE[2] ──▶ PE[3]
    │   (systolic data flow)
    │
    └── Shared Scratchpad Memory (SPM)
        └── 4 banks × 8192 words = 32768 words total
```

### Key Components

- **PE (Processing Element)**: `pe.cpp/h` - Individual processing element with compute and control traces
  - Compute Register File: 32 registers (reg[0..31])
  - Addressing Register File: 16 registers (gr[0..15])
  - Dual-trace execution: compute trace + control trace

- **PE Array Controller**: `pe_array.cpp/h` - Manages PE array and external I/O
  - Addressing registers: gr[0..15]
  - Input/output buffers (in_buf, out_buf)
  - 4 FIFOs for inter-iteration data buffering
  - Synchronization via gr[13] (AND of all PE gr[10] flags)

- **Scratchpad Memory (SPM)**: `data_buffer.cpp/h` - Shared memory accessible by all PEs
  - 32768 words total (4 banks × 8192 words)
  - 2-cycle access latency
  - 1 port per PE (read OR write, not both)
  - Virtual addressing per PE (with bank offset)
  - Physical addressing for interleaved access (mvi instruction)

- **Compute Unit**: `compute_unit_32.cpp/h` - ALU implementation for compute instructions

- **Control Unit**: Handles data movement and control flow instructions

### Instruction System

The simulator uses two separate instruction sets:

1. **Control Instructions** (64-bit, VLIW with 2 slots): Data movement, branches, memory operations
2. **Compute Instructions** (50-bit): Arithmetic operations

Instructions are generated by Python scripts in `scripts/` and stored in `instructions/` directory.

See `docs.md` for the complete ISA manual, including:
- Instruction encoding formats
- Opcode reference (mv, si, add, addi, bne, beq, etc.)
- SPM addressing modes (virtual vs. interleaved)
- Synchronization patterns

## Key Files

### Core Simulator
- `main.cpp` - Entry point, kernel selection
- `simulator.cpp/h` - Main simulation loop and event handling
- `pe_array.cpp/h` - Array controller and PE orchestration (6000+ lines, complex synchronization)
- `pe.cpp/h` - Individual PE implementation (3000+ lines)
- `data_buffer.cpp/h` - Scratchpad memory with latency modeling
- `sys_def.h` - System-wide parameters and constants

### Kernel Implementations
- `bsw.cpp/h` - Band Smith-Waterman simulation
- `wfa.cpp/h` - Wavefront Alignment simulation
- `phmm.cpp/h` - PairHMM simulation
- `poa.cpp/h` - Partial Order Alignment simulation
- `chain.cpp/h` - Chaining simulation

### Instruction Generation
- `scripts/opcodes.py` - Opcode definitions for Python generators
- `scripts/utils.py` - Helper functions for instruction encoding
- `scripts/*_instruction_generator.py` - Generate control/compute instructions for each kernel
- `scripts/*_throughput.py` - Throughput measurement scripts
- `scripts/*_check_correctness.py` - Correctness validation scripts

### Compute Components
- `alu_32.cpp/h` - 32-bit ALU
- `compute_unit_32.cpp/h` - Compute unit wrapper
- `regfile.cpp/h` - Register file
- `crossbar.cpp/h` - Interconnect
- `FIFO.cpp/h` - FIFO buffers
- `comp_decoder.cpp/h` - Compute instruction decoder

## Important Architectural Details

### SPM Access Constraints (CRITICAL)

The SPM has strict access rules that must be followed:

1. **2-cycle latency**: Must insert 2 no-ops between consecutive SPM accesses
2. **No simultaneous read/write**: Each PE has 1 port (read OR write per cycle)
3. **No pipelining**: Cannot issue new SPM request while one is in flight
4. **Destination restriction**: SPM loads can only write to `reg`, `gr`, or `out_port`

Illegal pattern example:
```python
f.write(data_movement_instruction(reg, SPM, 0, 0, 0, 0, 0, 0, 0, 1, mv))  # load
f.write(data_movement_instruction(SPM, reg, 0, 0, 0, 2, 0, 0, 5, 0, mv))  # ILLEGAL: same cycle store
```

Legal pattern:
```python
f.write(data_movement_instruction(reg, SPM, 0, 0, 0, 0, 0, 0, 0, 1, mv))  # load
f.write(data_movement_instruction(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, none))    # nop (cycle 1)
f.write(data_movement_instruction(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, none))    # nop (cycle 2)
f.write(data_movement_instruction(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, none))    # data ready
```

### VLIW Execution Order (CRITICAL)

Control instructions execute in pairs (2 slots), but the execution order is counter-intuitive:
- First written instruction → Slot 0 → executes SECOND
- Second written instruction → Slot 1 → executes FIRST

This matters for hazards involving arithmetic operations that write to `gr`:

```python
# INCORRECT - read sees NEW value because increment executes first
f.write(data_movement_instruction(reg, SPM, 0, 0, 0, 0, 0, 0, 0, 1, mv))   # Slot 0: executes 2nd
f.write(data_movement_instruction(gr, gr, 0, 0, 1, 0, 0, 0, 1, 1, addi))   # Slot 1: gr[1]++ executes 1st!

# CORRECT - place increment in Slot 0 so it executes AFTER the read
f.write(data_movement_instruction(gr, gr, 0, 0, 1, 0, 0, 0, 1, 1, addi))   # Slot 0: executes 2nd
f.write(data_movement_instruction(reg, SPM, 0, 0, 0, 0, 0, 0, 0, 1, mv))   # Slot 1: executes 1st
```

### Synchronization Pattern

PEs signal completion to the controller via `gr[10]`:

```python
# PE: Signal done
f.write(data_movement_instruction(gr, 0, 0, 0, 10, 0, 0, 0, 1, 0, si))  # gr[10] = 1

# PE: Wait for controller
f.write(data_movement_instruction(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, halt))
f.write(data_movement_instruction(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, halt))

# Controller: Wait for all PEs (gr[13] = AND of all PE gr[10])
f.write(data_movement_instruction(gr, gr, 0, 0, 0, 0, 0, 0, 1, 13, bne))  # spin until gr[13]==1

# Controller: Restart PEs at new PC
f.write(data_movement_instruction(0, 0, 0, 0, PE_START, 0, 0, 0, 0, 0, set_PC))
```

### Memory Configuration

SPM size is parameterized across multiple files. To change `SPM_BANK_SIZE`:

1. `sys_def.h`: Update `SPM_BANK_SIZE`, `SPM_ADDR_NUM`, `ADDR_LEN`, `PATTERN_START`, `TEXT_START`
2. `scripts/wfa_instruction_generator.py`: Update `BANK_SIZE`, `PATTERN_START`, derived constants
3. `pe_array.cpp`: Update `PADDING_SIZE`, `BLOCK_1_START` (magic instruction constants)

Current configuration: 8192 words/bank × 4 banks = 32768 words total.

## Development Workflow

### Adding a New Kernel

1. Create kernel simulator: `<kernel>.cpp/h` with `<kernel>_simulation()` function
2. Add to `main.cpp` kernel switch statement
3. Create instruction generator: `scripts/<kernel>_instruction_generator.py`
4. Create throughput script: `scripts/<kernel>_throughput.py` and `.sh`
5. Create correctness checker: `scripts/<kernel>_check_correctness.py`
6. Add kernel implementation in `kernel/<kernel>/`
7. Update `Makefile` if needed

### Debugging Tips

- Use `debug=1` to enable DEBUG macro
- Use `profile=1` to enable PROFILE macro
- **WFA-specific traces**:
  - `magic_wfs_out.txt` - Simulator's wavefront trace (step-by-step computation)
  - `wfaTrace.txt` - Reference/golden wavefront trace (for comparison)
  - Compare these files to identify where computation diverges
- Output files: `<kernel>_output.txt`, `<kernel>_sim_results/`
- Use `-s` flag to show output during simulation
- Address sanitizer is enabled by default (disable with `ADDRESS_SANITIZER=0`)

### Important Code Locations

- **Magic instruction loading**: `pe_array.cpp:~400-600` (loads DNA sequences into SPM for WFA)
- **PE decode logic**: `pe.cpp:decode_ctrl()` and `pe.cpp:decode_comp()`
- **SPM latency modeling**: `data_buffer.cpp:load()` and `data_buffer.cpp:store()`
- **Synchronization logic**: `pe_array.cpp:tick()` (gr[13] computation)
- **Instruction encoding**: `scripts/utils.py:data_movement_instruction()`

## WFA (Wavefront Alignment) Kernel Development

The WFA kernel is a key component of the GenDP simulator, implementing the Wavefront Alignment algorithm for sequence alignment. Understanding how to work with, debug, and verify the WFA kernel requires familiarity with several interconnected components.

### Key WFA Files

- **Instruction Trace**: `scripts/wfa_instruction_generator.py` - Generates control and compute instructions for the WFA algorithm
  - This is the primary file for understanding the WFA execution flow
  - Contains the programming logic for both controller and PE code
  - Defines memory layout, constants, and execution patterns

- **Simulator Integration**: `wfa.cpp/h` - WFA kernel simulation wrapper
  - Handles input/output, initialization, and result collection
  - Calls the PE array simulator with WFA-specific setup

- **Verification Scripts**:
  - `scripts/wfa_check_correctness.py` - Python script for comparing simulator output with expected results
  - `scripts/wfa_run_validation.sh` - Wrapper script that runs simulation and validation

### Understanding the WFA Implementation

To understand how the simulator works for WFA:

1. **Read the documentation**: `docs.md` contains the complete ISA programming guide, including:
   - Instruction encoding formats
   - Opcode reference and usage patterns
   - SPM access constraints
   - Synchronization mechanisms

2. **Study the instruction generator**: `scripts/wfa_instruction_generator.py`
   - Shows how control flow is structured
   - Demonstrates proper SPM access patterns with latency handling
   - Illustrates PE-controller synchronization
   - Contains memory layout constants (PATTERN_START, TEXT_START, etc.)

3. **Examine the simulator core**:
   - `pe_array.cpp` - Controller execution and PE orchestration
   - `pe.cpp` - PE execution, instruction decode
   - `data_buffer.cpp` - SPM access with latency modeling

### WFA Verification Workflow

```bash
# Step 1: Build the simulator
make

# Step 2: Run the WFA simulation
./sim -k 5 -i <input_file> -o <output_file> -n <num_cases>

# Step 3: Verify correctness
python3 scripts/wfa_check_correctness.py <output_file> <expected_output>
# Or use the wrapper:
bash scripts/wfa_run_validation.sh
```

### WFA Output Files

The verification process produces two key trace files:

1. **`magic_wfs_out.txt`** - Simulator's step-by-step wavefront trace
   - Generated by the simulator during execution
   - Contains wavefront values computed by the PE array
   - Shows the intermediate states of the M, I, D, and O wavefronts

2. **`wfaTrace.txt`** - Reference/golden wavefront trace
   - Generated by the reference implementation or verification script
   - Contains the expected correct wavefront values
   - Used for comparison against simulator output

### Expected Differences in Output

When comparing `magic_wfs_out.txt` and `wfaTrace.txt`, be aware of expected differences:

1. **Trailing differences**: The files may have different numbers of trailing elements
   - This is due to how many elements each implementation prints
   - Does not indicate an error

2. **Double-printed input wavefronts**: The simulator will print input wavefronts twice at each iteration
   - First print: Input wavefront loading phase
   - Second print: Input wavefront consumption phase
   - This is expected behavior and should be accounted for when comparing traces

3. **Format variations**: The exact formatting may differ slightly between traces

**Key Point**: Apart from the above expected differences, the wavefront values themselves should match exactly. Any discrepancies in actual computation results indicate a bug.

### Debugging WFA Issues

When debugging WFA problems:

1. **Check wavefront traces**: Compare `magic_wfs_out.txt` vs `wfaTrace.txt` to find where divergence occurs
2. **Verify SPM access patterns**: Ensure proper latency handling (2 no-ops between accesses)
3. **Check memory layout**: Verify PATTERN_START, TEXT_START, and other constants match between `sys_def.h` and `wfa_instruction_generator.py`
4. **Trace execution**: Add debug prints in `pe_array.cpp` or `pe.cpp` to track register values and PC
5. **Validate magic instruction loading**: Check `pe_array.cpp:~400-600` for DNA sequence loading into SPM

### WFA Memory Layout

The WFA algorithm uses a specific SPM memory layout (per bank):

```
Memory Block Structure (per iteration):
- Block 0: 7 × 32-word sections + 30-word padding + 2-word gap = 256 words
  - Sections: O (Open), M_in, I_in, D_in, M_out, I_out, D_out
- Block 1: Same structure = 256 words
- Pattern sequence region: 3840 words (addresses 512-4351)
- Text sequence region: 3840 words (addresses 4352-8191)
```

Constants defined in `scripts/wfa_instruction_generator.py`:
- `MEM_BLOCK_SIZE = 32` - Size of each wavefront section
- `PADDING_SIZE = 30` - Reserved padding per block
- `PATTERN_START = 512` - Start address for pattern DNA sequence
- `TEXT_START = 4352` - Start address for text DNA sequence
- `SWIZZLED_PATTERN_START`, `SWIZZLED_TEXT_START` - For interleaved access via `mvi` instruction

### Common WFA-Specific Issues

1. **Wavefront mismatch**: Often caused by incorrect loop bounds or iteration logic
2. **Memory overflow**: Pattern/text sequences exceed allocated SPM space
3. **Synchronization errors**: PEs not properly signaling completion via gr[10]
4. **Magic instruction failures**: DNA sequences not loaded correctly into SPM
5. **Interleaved access errors**: Incorrect use of `mvi` instruction or swizzled addresses

## Common Pitfalls

1. **SPM latency violations**: Not inserting enough no-ops between SPM accesses
2. **VLIW hazards**: Forgetting that Slot 1 executes before Slot 0
3. **Invalid destinations**: Using unsupported src/dest combinations (see docs.md tables)
4. **Controller arithmetic destinations**: Controller arithmetic ops can only write to gr, out_buf, or out_port
5. **Missing synchronization**: Forgetting to set gr[10]=1 in PEs or wait on gr[13] in controller
6. **Bank addressing**: Confusing virtual (per-PE) vs. physical (interleaved) SPM addressing

## Testing and Validation

### Generate Golden Output
```bash
# Run kernel to generate expected output
cd kernel/<kernel> && make -j
./<kernel>_test -i <input> -o <golden_output> -n <num_cases>
```

### Run Simulation
```bash
cd ../..
./sim -k <kernel_num> -i <input> -o <sim_output> -n <num_cases>
```

### Check Correctness
```bash
python3 scripts/<kernel>_check_correctness.py <sim_output> <golden_output>
```

### Measure Throughput
```bash
bash scripts/<kernel>_throughput.sh <num_cases>
```

## Additional Documentation

- **Complete ISA Manual**: See `docs.md` for detailed instruction encoding, opcode reference, addressing modes, and programming patterns
- **Kernel README**: `kernel/README.md` for kernel-specific compilation and execution details
- **Root README**: `README.md` for dataset setup and basic usage examples
